# Two-Table Flow: AviatorRound + analytics_round_signals

## Overview

The system now uses **two separate API calls** to properly save round data and ML predictions:

### Table 1: `AviatorRound`
Stores actual game rounds with auto-generated IDs.

### Table 2: `analytics_round_signals`
Stores ML predictions linked to rounds via `round_id`.

## Data Flow

```
Round Completes
    ↓
[API Call 1] Insert into AviatorRound
    ↓
Get auto-generated roundId
    ↓
Make ML Prediction
    ↓
[API Call 2] Insert into analytics_round_signals
    ↓
Link prediction to round via round_id
```

## Table Schemas

### AviatorRound
```sql
CREATE TABLE "AviatorRound" (
  "roundId" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "multiplier" REAL NOT NULL,
  "timestamp" TIMESTAMP
);
```

**We insert:**
- `multiplier`: Crash multiplier (e.g., 2.45)
- `timestamp`: When round ended

**Database auto-generates:**
- `roundId`: Auto-increment ID

### analytics_round_signals
```sql
CREATE TABLE "analytics_round_signals" (
  "id" BIGSERIAL PRIMARY KEY,
  "round_id" BIGINT NOT NULL,           -- Links to AviatorRound.roundId
  "multiplier" NUMERIC NOT NULL,        -- Predicted multiplier
  "model_name" TEXT NOT NULL,           -- "RandomForest"
  "model_output" JSONB NOT NULL,        -- Full prediction details
  "confidence" NUMERIC,                 -- 0-1 confidence score
  "metadata" JSONB DEFAULT '{}'::jsonb,
  "created_at" TIMESTAMP DEFAULT NOW()
);
```

**We insert:**
- `round_id`: The roundId from AviatorRound
- `multiplier`: Predicted crash multiplier
- `model_name`: "RandomForest"
- `model_output`: JSON with prediction details
- `confidence`: Model confidence (0-1)
- `metadata`: Extra info (next round number, stats)

## Code Changes Made

### 1. Fixed `insert_round()` method

**Before (WRONG):**
```python
data = {
    'roundId': unique_id,  # ❌ Trying to set auto-generated ID
    'multiplier': multiplier,
    'timestamp': timestamp
}
```

**After (CORRECT):**
```python
data = {
    'multiplier': float(multiplier),  # ✅ Let DB generate roundId
    'timestamp': timestamp.isoformat()
}

# Returns the auto-generated roundId
return round_id
```

### 2. Added `insert_analytics_signal()` method

```python
def insert_analytics_signal(
    round_id,      # Link to AviatorRound
    multiplier,    # Predicted value
    model_name,    # "RandomForest"
    model_output,  # JSON details
    confidence,    # 0-1 score
    metadata       # Extra info
)
```

### 3. Updated round completion flow

```python
# Step 1: Save round to AviatorRound
round_id = self.supabase.insert_round(
    round_number=round_summary.round_number,
    multiplier=round_summary.max_multiplier,
    timestamp=round_end_time
)

# Step 2: Make prediction and save to analytics_round_signals
if round_id:  # Only if round saved successfully
    self._make_prediction_for_next_round(
        next_round_number=round_summary.round_number + 1,
        last_round_id=round_id  # Pass the round_id
    )
```

## Example Output

### Round Save (API Call 1)
```
[10:15:30] INFO: Round 1 saved to Supabase (ID: 123, multiplier: 2.45x)
```

### Prediction Save (API Call 2)
```
================================================================================
ML PREDICTION FOR ROUND 2
================================================================================
Predicted Crash Multiplier: 3.21x
Confidence: 67.5%
Model: RandomForest
Training Samples: 50
================================================================================

[10:15:31] INFO: Analytics signal saved (ID: 456, round: 123, model: RandomForest)
```

## Database Queries

### View Rounds
```sql
SELECT * FROM "AviatorRound"
ORDER BY "timestamp" DESC
LIMIT 10;
```

### View Predictions
```sql
SELECT
    ars.id,
    ars.round_id,
    ar.multiplier as actual_multiplier,
    ars.multiplier as predicted_multiplier,
    ars.confidence,
    ars.model_name,
    ars.created_at
FROM analytics_round_signals ars
JOIN "AviatorRound" ar ON ars.round_id = ar."roundId"
ORDER BY ars.created_at DESC
LIMIT 10;
```

### Calculate Prediction Accuracy
```sql
SELECT
    COUNT(*) as total_predictions,
    AVG(ABS(ar.multiplier - ars.multiplier)) as avg_error,
    AVG(ars.confidence) as avg_confidence
FROM analytics_round_signals ars
JOIN "AviatorRound" ar ON ars.round_id = ar."roundId"
WHERE ars.model_name = 'RandomForest';
```

## Fixing the Trigger Issue

Your `after_insert_analytics_generate` trigger is calling a function that references `m_std`. You have two options:

### Option 1: Fix the Trigger Function

Update `analytics_generate_round_signal()` function to NOT reference `m_std`:

```sql
CREATE OR REPLACE FUNCTION analytics_generate_round_signal()
RETURNS TRIGGER AS $$
BEGIN
    -- Your logic here, but DON'T reference m_std
    -- Work with NEW.multiplier, NEW.timestamp, etc.
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Option 2: Disable the Trigger (Temporary)

```sql
ALTER TABLE "AviatorRound"
DISABLE TRIGGER after_insert_analytics_generate;
```

Then test if rounds save successfully.

## Testing

1. **Run the application:**
   ```bash
   python.exe main.py
   ```

2. **Wait for a round to complete**

3. **Look for success messages:**
   ```
   [10:15:30] INFO: Round 1 saved to Supabase (ID: 123, multiplier: 2.45x)
   [10:15:31] INFO: Analytics signal saved (ID: 456, round: 123, model: RandomForest)
   ```

4. **Verify in Supabase:**
   ```sql
   -- Check rounds
   SELECT COUNT(*) FROM "AviatorRound";

   -- Check predictions
   SELECT COUNT(*) FROM analytics_round_signals;
   ```

## Benefits of Two-Table Approach

✅ **Clean Separation**
- Rounds table: Simple, clean, just game data
- Analytics table: All ML/prediction data separate

✅ **Flexible Schema**
- Can add new models without changing rounds table
- Multiple predictions per round possible

✅ **Better Performance**
- Rounds table stays small and fast
- Analytics table can grow without affecting round inserts

✅ **Easier Debugging**
- If predictions fail, rounds still save
- Can test rounds independently from ML

## Summary

- **AviatorRound**: Game results with auto-generated IDs
- **analytics_round_signals**: ML predictions linked to rounds
- **Two API calls**: Insert round → Get ID → Insert prediction
- **Fix trigger**: Make sure `analytics_generate_round_signal()` function doesn't reference missing columns
