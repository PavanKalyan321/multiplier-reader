# Supabase client for storing round data
from supabase import create_client, Client
from datetime import datetime
import os
import time


class SupabaseLogger:
    """Handle Supabase database operations for round data"""

    def __init__(self, url=None, key=None):
        """Initialize Supabase client with credentials"""
        self.url = url or os.getenv('SUPABASE_URL')
        self.key = key or os.getenv('SUPABASE_KEY')
        self.client: Client = None
        self.enabled = False

        if self.url and self.key:
            try:
                self.client = create_client(self.url, self.key)
                self.enabled = True
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Supabase connected successfully")
            except Exception as e:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Supabase connection failed: {e}")
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Continuing with local logging only")
        else:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Supabase credentials not provided, using local logging only")

    def insert_round(self, round_number, multiplier, timestamp=None):
        """
        Insert round data into AviatorRound table

        Args:
            round_number (int): Round sequence number (not used)
            multiplier (float): Final/crash multiplier value
            timestamp (datetime): Round end timestamp (defaults to now)

        Returns:
            int: roundId if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            if timestamp is None:
                timestamp = datetime.now()

            # Prepare data - roundId is auto-generated by database
            # Only insert multiplier and timestamp
            data = {
                'multiplier': float(multiplier),
                'timestamp': timestamp.isoformat()
            }

            # Insert into AviatorRound table
            response = self.client.table('AviatorRound').insert(data).execute()

            # Extract the auto-generated roundId from response
            if response.data and len(response.data) > 0:
                round_id = response.data[0].get('roundId')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Round {round_number} saved to Supabase (ID: {round_id}, multiplier: {multiplier:.2f}x)")
                return round_id
            else:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Round saved but no ID returned")
                return None

        except Exception as e:
            error_msg = str(e)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save round to Supabase: {error_msg}")

            # Provide specific hints based on error
            if 'does not exist' in error_msg:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] HINT: Check if trigger function 'analytics_generate_round_signal' exists and has correct columns.")
            elif 'permission denied' in error_msg:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] HINT: Check RLS policies on AviatorRound table.")

            return None

    def insert_analytics_signal(self, round_id: int, actual_multiplier: float,
                                predicted_multiplier: float, model_name: str,
                                confidence: float, prediction_range: tuple,
                                model_output: dict = None, metadata: dict = None,
                                timestamp: datetime = None):
        """
        Insert analytics signal into analytics_round_signals table

        Args:
            round_id (int): The roundId from AviatorRound table
            actual_multiplier (float): The actual multiplier from the last round
            predicted_multiplier (float): The predicted multiplier for next round
            model_name (str): Name of the ML model (e.g., "RandomForest")
            confidence (float): Model confidence (0-1, will be converted to percentage)
            prediction_range (tuple): Min and max prediction range (min, max)
            model_output (dict): Model output data as JSON (optional, for backward compatibility)
            metadata (dict): Additional metadata (optional)
            timestamp (datetime): Optional timestamp to use (same as the round's timestamp)

        Returns:
            int: signal id if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            # Build payload structure
            import json
            payload = {
                'modelName': model_name,
                'id': round_id,  # Using round_id as the reference
                'expectedOutput': predicted_multiplier,
                'confidence': f"{confidence * 100:.0f}%",
                'range': f"{prediction_range[0]:.2f}-{prediction_range[1]:.2f}"
            }

            # Prepare data matching analytics_round_signals schema
            data = {
                'round_id': round_id,
                'multiplier': float(actual_multiplier),  # Actual multiplier from last round
                'model_name': model_name,
                'model_output': model_output or {},
                'confidence': float(confidence),
                'metadata': metadata or {},
                'payload': json.dumps(payload)  # Store prediction structure as JSON text
            }

            # Add timestamp if provided (to match the AviatorRound entry)
            if timestamp is not None:
                data['created_at'] = timestamp.isoformat()

            # Insert into analytics_round_signals table
            response = self.client.table('analytics_round_signals').insert(data).execute()

            # Extract signal id from response
            if response.data and len(response.data) > 0:
                signal_id = response.data[0].get('id')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Analytics signal saved (ID: {signal_id}, round: {round_id}, actual: {actual_multiplier:.2f}x, predicted: {predicted_multiplier:.2f}x)")
                return signal_id

            return None

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save analytics signal: {e}")
            return None

    def insert_multi_model_signal(self, round_id: int, actual_multiplier: float,
                                   predictions: list, timestamp: datetime = None):
        """
        Insert analytics signal with multiple model predictions

        Args:
            round_id (int): The roundId from AviatorRound table
            actual_multiplier (float): The actual multiplier from the last round
            predictions (list): List of prediction dicts from all models
            timestamp (datetime): Optional timestamp to use (same as the round's timestamp)

        Returns:
            int: signal id if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            import json

            # Build payload with all model predictions
            payload_models = []
            for pred in predictions:
                model_data = {
                    'modelName': pred['model_name'],
                    'expectedOutput': pred['predicted_multiplier'],
                    'confidence': f"{pred['confidence'] * 100:.0f}%",
                    'range': f"{pred['range'][0]:.2f}-{pred['range'][1]:.2f}",
                    'bet': pred.get('bet', False)  # Include betting flag
                }
                payload_models.append(model_data)

            # Overall payload structure
            payload = {
                'roundId': round_id,
                'actualMultiplier': actual_multiplier,
                'models': payload_models,
                'timestamp': datetime.now().isoformat()
            }

            # Use ensemble or first model for main fields
            ensemble = predictions[0]  # First should be ensemble if available

            # Prepare data matching analytics_round_signals schema
            data = {
                'round_id': round_id,
                'multiplier': float(actual_multiplier),  # Actual multiplier from last round
                'model_name': 'MultiModel',  # Indicate this is multi-model
                'model_output': {
                    'num_models': len(predictions),
                    'models': [p['model_name'] for p in predictions]
                },
                'confidence': float(ensemble['confidence']),
                'metadata': {
                    'prediction_count': len(predictions),
                    'bet_consensus': sum(1 for p in predictions if p.get('bet', False))
                },
                'payload': json.dumps(payload)  # Store all predictions as JSON text
            }

            # Add timestamp if provided (to match the AviatorRound entry)
            if timestamp is not None:
                data['created_at'] = timestamp.isoformat()

            # Insert into analytics_round_signals table
            response = self.client.table('analytics_round_signals').insert(data).execute()

            # Extract signal id from response
            if response.data and len(response.data) > 0:
                signal_id = response.data[0].get('id')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Multi-model signal saved (ID: {signal_id}, round: {round_id}, {len(predictions)} models)")
                return signal_id

            return None

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save multi-model signal: {e}")
            return None

    def get_recent_rounds(self, limit: int = 1000):
        """
        Fetch recent rounds from Supabase to initialize ML model

        Args:
            limit (int): Number of recent rounds to fetch

        Returns:
            list: List of round dictionaries, or empty list if failed
        """
        if not self.enabled:
            return []

        try:
            response = self.client.table('AviatorRound').select('*').order('timestamp', desc=True).limit(limit).execute()

            if response.data:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Fetched {len(response.data)} rounds from Supabase for ML training")
                return response.data

            return []

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to fetch rounds from Supabase: {e}")
            return []
