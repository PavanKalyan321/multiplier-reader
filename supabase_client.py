# Supabase client for storing round data
from supabase import create_client, Client
from datetime import datetime
import os
import time


class SupabaseLogger:
    """Handle Supabase database operations for round data"""

    def __init__(self, url=None, key=None):
        """Initialize Supabase client with credentials"""
        self.url = url or os.getenv('SUPABASE_URL')
        self.key = key or os.getenv('SUPABASE_KEY')
        self.client: Client = None
        self.enabled = False

        if self.url and self.key:
            try:
                self.client = create_client(self.url, self.key)
                self.enabled = True
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Supabase connected successfully")
            except Exception as e:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Supabase connection failed: {e}")
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Continuing with local logging only")
        else:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Supabase credentials not provided, using local logging only")

    def insert_round(self, round_number, multiplier, timestamp=None):
        """
        Insert round data into AviatorRound table

        Args:
            round_number (int): Round sequence number (not used)
            multiplier (float): Final/crash multiplier value
            timestamp (datetime): Round end timestamp (defaults to now)

        Returns:
            int: roundId if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            if timestamp is None:
                timestamp = datetime.now()

            # Prepare data - roundId is auto-generated by database
            # Only insert multiplier and timestamp
            data = {
                'multiplier': float(multiplier),
                'timestamp': timestamp.isoformat()
            }

            # Insert into AviatorRound table
            response = self.client.table('AviatorRound').insert(data).execute()

            # Extract the auto-generated roundId from response
            if response.data and len(response.data) > 0:
                round_id = response.data[0].get('roundId')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Round {round_number} saved to Supabase (ID: {round_id}, multiplier: {multiplier:.2f}x)")
                return round_id
            else:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Round saved but no ID returned")
                return None

        except Exception as e:
            error_msg = str(e)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save round to Supabase: {error_msg}")

            # Provide specific hints based on error
            if 'does not exist' in error_msg:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] HINT: Check if trigger function 'analytics_generate_round_signal' exists and has correct columns.")
            elif 'permission denied' in error_msg:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] HINT: Check RLS policies on AviatorRound table.")

            return None

    def insert_analytics_signal(self, round_id: int, actual_multiplier: float,
                                predicted_multiplier: float, model_name: str,
                                confidence: float, prediction_range: tuple,
                                model_output: dict = None, metadata: dict = None,
                                timestamp: datetime = None):
        """
        Insert analytics signal into analytics_round_signals table

        Args:
            round_id (int): The roundId from AviatorRound table
            actual_multiplier (float): The actual multiplier from the last round
            predicted_multiplier (float): The predicted multiplier for next round
            model_name (str): Name of the ML model (e.g., "RandomForest")
            confidence (float): Model confidence (0-1, will be converted to percentage)
            prediction_range (tuple): Min and max prediction range (min, max)
            model_output (dict): Model output data as JSON (optional, for backward compatibility)
            metadata (dict): Additional metadata (optional)
            timestamp (datetime): Optional timestamp to use (same as the round's timestamp)

        Returns:
            int: signal id if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            # Build payload structure (rounded to 1 decimal)
            import json
            payload = {
                'modelName': model_name,
                'id': round_id,  # Using round_id as the reference
                'expectedOutput': round(predicted_multiplier, 1),
                'confidence': f"{confidence * 100:.0f}%",
                'range': f"{prediction_range[0]:.1f}-{prediction_range[1]:.1f}"
            }

            # Prepare data matching analytics_round_signals schema
            data = {
                'round_id': round_id,
                'multiplier': round(actual_multiplier, 1),  # Actual multiplier from last round
                'model_name': model_name,
                'model_output': model_output or {},
                'confidence': round(confidence, 2),  # Round confidence to 2 decimals (0.XX)
                'metadata': metadata or {},
                'payload': json.dumps(payload)  # Store prediction structure as JSON text
            }

            # Add timestamp if provided (to match the AviatorRound entry)
            if timestamp is not None:
                data['created_at'] = timestamp.isoformat()

            # Insert into analytics_round_signals table
            response = self.client.table('analytics_round_signals').insert(data).execute()

            # Extract signal id from response
            if response.data and len(response.data) > 0:
                signal_id = response.data[0].get('id')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Analytics signal saved (ID: {signal_id}, round: {round_id}, actual: {actual_multiplier:.1f}x, predicted: {predicted_multiplier:.1f}x)")
                return signal_id

            return None

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save analytics signal: {e}")
            return None

    def insert_multi_model_signal(self, round_id: int, actual_multiplier: float,
                                   predictions: list, timestamp: datetime = None):
        """
        Insert analytics signal with multiple model predictions

        Args:
            round_id (int): The roundId from AviatorRound table
            actual_multiplier (float): The actual multiplier from the last round
            predictions (list): List of prediction dicts from all models
            timestamp (datetime): Optional timestamp to use (same as the round's timestamp)

        Returns:
            int: signal id if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            import json

            # Build payload with all model predictions (rounded to 1 decimal)
            payload_models = []
            for pred in predictions:
                model_data = {
                    'modelName': pred['model_name'],
                    'expectedOutput': round(pred['predicted_multiplier'], 1),
                    'confidence': f"{pred['confidence'] * 100:.0f}%",
                    'range': f"{pred['range'][0]:.1f}-{pred['range'][1]:.1f}",
                    'bet': pred.get('bet', False)  # Include betting flag
                }
                payload_models.append(model_data)

            # Overall payload structure
            payload = {
                'roundId': round_id,
                'actualMultiplier': round(actual_multiplier, 1),
                'models': payload_models,
                'timestamp': datetime.now().isoformat()
            }

            # Use ensemble or first model for main fields
            ensemble = predictions[0]  # First should be ensemble if available

            # Prepare data matching analytics_round_signals schema
            data = {
                'round_id': round_id,
                'multiplier': float(actual_multiplier),  # Actual multiplier from last round
                'model_name': 'MultiModel',  # Indicate this is multi-model
                'model_output': {
                    'num_models': len(predictions),
                    'models': [p['model_name'] for p in predictions]
                },
                'confidence': float(ensemble['confidence']),
                'metadata': {
                    'prediction_count': len(predictions),
                    'bet_consensus': sum(1 for p in predictions if p.get('bet', False))
                },
                'payload': json.dumps(payload)  # Store all predictions as JSON text
            }

            # Add timestamp if provided (to match the AviatorRound entry)
            if timestamp is not None:
                data['created_at'] = timestamp.isoformat()

            # Insert into analytics_round_signals table
            response = self.client.table('analytics_round_signals').insert(data).execute()

            # Extract signal id from response
            if response.data and len(response.data) > 0:
                signal_id = response.data[0].get('id')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Multi-model signal saved (ID: {signal_id}, round: {round_id}, {len(predictions)} models)")
                return signal_id

            return None

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save multi-model signal: {e}")
            return None

    def insert_advanced_multi_model_signal(
        self,
        round_id: int,
        actual_multiplier: float,
        ensemble_prediction: dict,
        hybrid_decision: dict,
        all_predictions: dict,
        patterns: dict,
        timestamp: datetime = None
    ):
        """
        Insert analytics signal with advanced multi-model predictions (25+ models).

        Args:
            round_id: The roundId from AviatorRound table
            actual_multiplier: The actual multiplier from the last round
            ensemble_prediction: Ensemble prediction dictionary
            hybrid_decision: Hybrid strategy decision dictionary
            all_predictions: All model predictions grouped by type
            patterns: Pattern detection results
            timestamp: Optional timestamp

        Returns:
            int: signal id if successful, None otherwise
        """
        if not self.enabled:
            return None

        try:
            import json

            def round_floats(obj, decimals=1):
                """Recursively round all float values to specified decimal places"""
                if isinstance(obj, float):
                    return round(obj, decimals)
                elif isinstance(obj, dict):
                    return {k: round_floats(v, decimals) for k, v in obj.items()}
                elif isinstance(obj, list):
                    return [round_floats(item, decimals) for item in obj]
                elif isinstance(obj, tuple):
                    return tuple(round_floats(item, decimals) for item in obj)
                else:
                    return obj

            # Round all predictions to 1 decimal place
            ensemble_rounded = round_floats(ensemble_prediction, 1)
            hybrid_rounded = round_floats(hybrid_decision, 1)
            predictions_rounded = round_floats(all_predictions, 1)
            patterns_rounded = round_floats(patterns, 1)

            # Build comprehensive payload
            payload = {
                'modelVersion': 'advanced_v1',
                'roundId': int(round_id),
                'actualMultiplier': round(actual_multiplier, 1),
                'timestamp': datetime.now().isoformat(),
                'ensemble': ensemble_rounded,
                'hybridStrategy': hybrid_rounded,
                'modelPredictions': {
                    'legacy': predictions_rounded.get('legacy', []),
                    'automl': predictions_rounded.get('automl', []),
                    'trained': predictions_rounded.get('trained', []),
                    'classifiers': predictions_rounded.get('classifiers', [])
                },
                'patterns': patterns_rounded
            }

            # Calculate summary statistics
            total_models = sum(len(v) for v in all_predictions.values())
            total_bet_votes = sum(
                sum(1 for model in models if model.get('bet', False))
                for models in all_predictions.values()
            )

            # Prepare data
            data = {
                'round_id': int(round_id),
                'multiplier': float(actual_multiplier),
                'model_name': 'AdvancedMultiModel',
                'model_output': {
                    'version': 'advanced_v1',
                    'total_models': int(total_models),
                    'model_groups': {k: len(v) for k, v in all_predictions.items()},
                    'hybrid_position': hybrid_decision.get('position')
                },
                'confidence': float(ensemble_prediction.get('confidence', 0.5)),
                'metadata': {
                    'total_bet_votes': int(total_bet_votes),
                    'patterns_detected': [k for k, v in patterns.items() if v.get('detected', True)],
                    'hybrid_action': hybrid_decision.get('action'),
                    'hybrid_target': hybrid_decision.get('target_multiplier')
                },
                'payload': json.dumps(payload)
            }

            if timestamp:
                data['created_at'] = timestamp.isoformat()

            # Insert
            response = self.client.table('analytics_round_signals').insert(data).execute()

            if response.data and len(response.data) > 0:
                signal_id = response.data[0].get('id')
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Advanced multi-model signal saved (ID: {signal_id})")
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Models: {total_models} total, {total_bet_votes} vote BET")
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Hybrid: Position {hybrid_decision.get('position', 'None')} - {hybrid_decision.get('action')}")
                return signal_id

            return None

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to save advanced signal: {e}")
            import traceback
            traceback.print_exc()
            return None

    def get_recent_rounds(self, limit: int = None):
        """
        Fetch recent rounds from Supabase to initialize ML model

        Args:
            limit (int): Number of recent rounds to fetch (None = fetch all available)

        Returns:
            list: List of round dictionaries, or empty list if failed
        """
        if not self.enabled:
            return []

        try:
            # Fetch all rounds if limit is None, otherwise use limit
            query = self.client.table('AviatorRound').select('*').order('timestamp', desc=True)

            if limit is not None:
                query = query.limit(limit)

            response = query.execute()

            if response.data:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] INFO: Fetched {len(response.data)} rounds from Supabase for ML training")
                return response.data

            return []

        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] WARNING: Failed to fetch rounds from Supabase: {e}")
            return []
